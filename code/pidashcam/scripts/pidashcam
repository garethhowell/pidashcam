#!/usr/bin/python -p

"""PiDashCam Raspberry Pi dashcam

A systemd compliant multi-threaded daemon to record video and respond to button presses

"""

rev = '0.0.1dev3'
button_delay = 0.2
speedConv = 2.23694 # convert m/s to mph
BOUNCE_TIME = 300

# Standard libraries
import io, os, sys, threading, termios, tty
import atexit, socket
from time import time, sleep
from signal import pause
from datetime import datetime, timedelta
import keyboard
import argparse
import logging
import logging.handlers
import xmltodict
import signal

# Specials
import RPi.GPIO as GPIO
import picamera
from gps import *

# Inter-thread communication events
flushBuffer = threading.Event()
recording = threading.Event()
shutdown = threading.Event()

#global variables
gpsd = None
recordingLED = None


class CameraThread(threading.Thread):
    """CameraThread

    The thread that manages the PiCamera
    """

    def __init__(self, name):
        threading.Thread.__init__(self)
        self.name = name
        self.log = logging.getLogger(__name__)
        self.log.debug("CameraThread.__init__()")
        self.running = True
        self.camera = picamera.PiCamera()

    def run(self):
        global gpsd, flushbuffer, recording, shutdown
        global recordingLED
        self.log.debug("CameraThread.run()")

        self.camera.resolution = (cameraRes['h'], cameraRes['v'])
        self.camera.vflip = True
        self.camera.hflip = True
        self.camera.annotate_background = picamera.Color('black')
        stream = picamera.PiCameraCircularIO(self.camera, seconds=buffSize)

        # Main Loop
        while not shutdown.isSet():
            while recording.isSet():
                recordingLED.start(50)
                self.log.debug('Recording to ' + str(buffSize) + ' seconds buffer')
                self.camera.start_recording(stream, format=videoFormat)
                while recording.isSet():
                    self.camera.wait_recording(0.2)
                    # Update the annotation text
                    i = datetime.now()
                    now = i.strftime('%d-%b-%d %H:%M:%S')
                    lat = gpsd.fix.latitude
                    lon = gpsd.fix.longitude
                    speed = gpsd.fix.speed * speedConv
                    track = gpsd.fix.track
                    self.camera.annotate_text = now + " " + "{0:0.3f}".format(lat) + " " + "{0:0.3f}".format(lon) + " " + "{0:0.0f}".format(speed) + " m/s " + "{0:0.0f}".format(track) + " True"
                    # Check if we need to save the buffer
                    if flushBuffer.isSet():
                        i = datetime.now()
                        f = i.strftime('%Y%m%d-%H%M%S.' + videoFormat)
                        outFile = str(destDir) + '/' + f
                        self.log.debug('Flushing buffer to ' + outFile)
                        stream.copy_to(outFile)
                        self.log.debug('Switching back to recording to buffer..')
                        flushBuffer.clear()
                        recordingLED.ChangeFrequency(0.5) # extinguish LED_1
                    # Pause recording if necessary
                    if not recording.isSet():
                        self.log.debug("Recording paused")
                        recordingLED.stop()
                    if shutdown.isSet():
                        flushBuffer.set()
                        recording.clear()
            sleep(1)
        self.camera.close()
        self.log.debug("Ending camera thread")

## GpsPoller Thread

class GpsPoller(threading.Thread):
    """
    GPSPoller thread

    Sets up a connection to the GPS system daemon and enters Loop
    to update the current GPS information
    """

    def __init__(self, name):
        threading.Thread.__init__(self)
        self.name = name
        self.log = logging.getLogger(__name__)
        self.log.debug("GPSPoller.__init__()")
        #bring the gps global variable into scope
        global gpsd
        #start updating the GPS info
        gpsd = gps(mode=WATCH_ENABLE)
        current_value = None
        self.running = True #setting the thread running to true

    def run(self):
        global shutdown, gpsd
        self.log.debug("GPSPoller.run()")
        while not shutdown.isSet():
            #Continue to loop and grab EACH set of gpsd info
            gpsd.next()
        self.log.debug("Ending GPS thread")


class PiDashCam():
    """
    PiDashCam - main thread
    """
    def __init__(self):
        self.log  = logging.getLogger(__name__)
        self.log.debug("PiDashCam.__init__()")

        # Setup a callback to catch SIGTERM
        signal.signal(signal.SIGTERM, self.sigcatch)

        global recordingLED

        # GPIO initialisation
        GPIO.setmode(GPIO.BCM)
        GPIO.setwarnings(False)
        GPIO.setup(BUTTON_A, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        GPIO.setup(BUTTON_B, GPIO.IN, pull_up_down=GPIO.PUD_UP)

        GPIO.setup(LED_1, GPIO.OUT)
        recordingLED = GPIO.PWM(LED_1, 0.5)

        GPIO.add_event_detect(BUTTON_A, GPIO.FALLING, callback=self.buttonAPressed, bouncetime=BOUNCE_TIME)
        GPIO.add_event_detect(BUTTON_B, GPIO.FALLING, callback=self.buttonBPressed, bouncetime=BOUNCE_TIME)

    def buttonAPressed(self, channel):
        """
        Button A interrupt service routine
        Flush the in-memory buffer
        """

        # This test is here because the user *might* have another HAT plugged in or another circuit that produces a
        # falling-edge signal on another GPIO pin.
        if channel != BUTTON_A:
            return

        self.log.debug('Button A has been pressed')
        global recordingLED
        t = threading.Timer(extraTime, self.setFlushBuffer)
        t.start()
        # Start flashing LED1 more frequently
        recordingLED.ChangeFrequency(1)


    def buttonBPressed(self, channel):
        """
        Button B interrupt service routine
        Pause/resume recording
        """

        # This test is here because the user *might* have another HAT plugged in or another circuit that produces a
        # falling-edge signal on another GPIO pin.
        if channel != BUTTON_B:
            return

        global flushBuffer, recording
        global recordingLED
        self.log.debug('Button B has been pressed')
        if recording.isSet():
            flushBuffer.set()
            sleep (1)
            recording.clear()
            recordingLED.stop()
        else:
            recording.set()
            recordingLED.ChangeFrequency(0.5)

    def sigcatch(self, signum, frame):
        """
        Signal handler
        """
        global flushBuffer, recording, shutdown

        if signum == signal.SIGTERM:
            # Probably been sent from systemctl stop
            # shutdown gracefully
            self.log.debug("SIGTERM received, shutting down")
            flushBuffer.set()
            sleep(1)
            recording.clear()
            sleep(1)
            shutdown.set()
            sleep(1)
            sys.exit(0)

    def cleanup(self):
        """
        GPIO cleanup
        """
        #TODO: close other threads down before quitting?

        self.log.debug("Cleanup")
        self.log.info("Stopped")
        #        GPIO.cleanup()

    def setFlushBuffer(self):
        global flushBuffer
        flushBuffer.set()

    def getch(self):
        """ getch - utility function to read a character from the keyboard
        """

        ch = ' '
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

    def run(self):

        global recording, flushBuffer, shutdown, gpsT, cameraT
        global recordingLED
        self.log.debug("PiDashCam.run()")

        # register function to cleanup at exit
        atexit.register(self.cleanup)

        gpsT = GpsPoller("gpsT") # create the GPS thread
        gpsT.start()
        cameraT = CameraThread("cameraT") # ditto the Camera thread
        recording.set()
        flushBuffer.clear()
        shutdown.clear()
        cameraT.start()

        # Main Loop
        while not shutdown.isSet():
            # Only check for keyboard characters if a keyboard is connected!
            # This won't be the case if we are running under systemd
            if sys.stdin.isatty():
                char = self.getch()
                if char == "s":
                    self.log.debug("save")
                    t = threading.Timer(extraTime, self.setFlushBuffer)
                    t.start()
                elif char == "q":
                    self.log.debug("Shutdown")
                    shutdown.set()
            sleep(1)

        # Shutdown
        self.log.debug("Shutting down, waiting for threads to die")
        shutdown.set()
        gpsT.join()
        self.log.debug("GPS thread died")
        cameraT.join()
        self.log.debug("Camera thread died.")
        self.log.info("Exiting")

class OneLineExceptionFormatter(logging.Formatter):
    def formatException(self, exc_info):
        result = super().formatException(exc_info)
        return repr(result)

    def format(self, record):
        result = super().format(record)
        if record.exc_text:
            result = result.replace("n", "")
        return result

# parse the command-line
parser = argparse.ArgumentParser()
parser.add_argument('-pre', '--prerecord', help='Pre-recording time (secs)', default='30')
parser.add_argument('-post', '--postrecord', help='Post-recording time (secs)', default='30')
parser.add_argument('-res', '--resolution', help='video resolution (hxv) in pixels', default='1440x1280')
parser.add_argument('-ba', '--button_a', help='Button A GPIO Pin', default='23')
parser.add_argument('-bb', '--button_b', help='Button B GPIO Pin', default='24')
parser.add_argument('-led', '--led', help='LED GPIO Pin', default='16')
parser.add_argument('-d', '--destdir', help='Destination directory for videos',  default='/home/pi/PiDashCam/Videos')
parser.add_argument('-v', '--video_format', help="format of video, 'h264' or 'mjpeg'", default='h264', choices=['h264', 'mjpeg'])
parser.add_argument('-l', '--log-level', help="Log level, 'info' or 'debug'", default='info', choices=['info', 'debug'])
args = parser.parse_args()
#handler = logging.StreamHandler()
#formatter = OneLineExceptionFormatter(logging.BASIC_FORMAT)
#handler.setFormatter(formatter)
logging.basicConfig(level = {'info':logging.INFO, 'debug':logging.DEBUG}[args.log_level])
log = logging.getLogger("pidashcam")
#log.addHandler(handler)
log.setLevel({'info':logging.INFO, 'debug':logging.DEBUG}[args.log_level])
log.info("piDashCam version "  + str(rev) + " started")
log.debug(args)
destDir = args.destdir
videoFormat = args.video_format
BUTTON_A = int(args.button_a)
BUTTON_B = int(args.button_b)
LED_1 = int(args.led)
cameraRes = {'h': 1440,'v': 1280}
buffSize = int(args.prerecord)
extraTime = int(args.postrecord)
dashcam = PiDashCam()
dashcam.run()
