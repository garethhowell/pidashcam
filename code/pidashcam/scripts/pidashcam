#!/usr/bin/python

"""

PiDashCam Raspberry Pi dashcam

"""

rev = '0.2.1'
destDir = '/home/pi/PiDashCam/Videos'
fileExt = "h264"
buffSize = 10 # size of in-memory buffer: secs
extraTime = 10 # extra seconds to save: secs
button_delay = 0.2
speedConv = 2.23694 # convert m/s to mph
cameraRes = {'h': 1280,'v': 960}
cameraFormat = 'h264'
BUTTON_A = 23
BUTTON_B = 24
BOUNCE_TIME = 300
LED_1 = 16
LED_1_LED = None
LED_2 = 20
LED_2_LED = None

gpsd = None #setting the global variable
camera = None



## PiDashCam

import io, os, sys, picamera, threading, termios, tty
import atexit, socket
import RPi.GPIO as GPIO #to access the GPIO pins
from time import time, sleep
from signal import pause
from datetime import datetime, timedelta
import keyboard, logging, logging.handlers
from gps import *
import argparse
import logging
import logging.handlers
import xmltodict
import signal

from pimodules.daemon import Daemon # resuse PiModules' Daemon class

# Inter-thread communication events
flushBuffer = threading.Event()
recording = threading.Event()
shutdown = threading.Event()

# Thread objects
#cameraT = None
gpsT = None


class CameraThread(threading.Thread):

    def __init__(self, name, log):
        global buffSize, cameraRes
        threading.Thread.__init__(self)
        self.name = name
        self.log = log
        self.log.debug("CameraT init")
        self.running = True


    def run(self):
        global gpsd, destDir, speedConv, cameraFormat, fileExt, flushbuffer, buffSize, recording, shutdown, LED_1, LED_1_LED, LED_2, LED_2_LED
        self.log.debug("cameraT running")

        camera = picamera.PiCamera()
        camera.resolution = (cameraRes['h'], cameraRes['v'])
        camera.vflip = True
        camera.hflip = True
        camera.annotate_background = picamera.Color('black')
        stream = picamera.PiCameraCircularIO(camera, seconds=buffSize)


        while not shutdown.isSet():
            while recording.isSet():
                LED_1_LED.start(50)
                i = datetime.now()
                now = i.strftime('%d %b %d %H:%M:%S')
                self.log.debug('started recording to ' + str(buffSize) + ' seconds buffer at ' + now)
                camera.led = True
                camera.start_recording(stream, format=cameraFormat)
                while recording.isSet():
                    camera.wait_recording(0.2)
                    i = datetime.now()
                    now = i.strftime('%d-%b-%d %H:%M:%S')
                    lat = gpsd.fix.latitude
                    lon = gpsd.fix.longitude
                    speed = gpsd.fix.speed * speedConv
                    track = gpsd.fix.track
                    camera.annotate_text = now + " " + "{0:0.3f}".format(lat) + " " + "{0:0.3f}".format(lon) + " " + "{0:0.0f}".format(speed) + " m/s " + "{0:0.0f}".format(track) + " True"
                    if flushBuffer.isSet():
                        self.log.debug("flush")
                        i = datetime.now()
                        f = i.strftime('%Y%m%d-%H%M%S.' + fileExt)
                        outFile = str(destDir) + '/' + f
                        self.log.debug('saving file... ' + outFile)
                        stream.copy_to(outFile)
                        self.log.debug('switching back to recording to buffer..')
                        flushBuffer.clear()
                        LED_1_LED.ChangeFrequency(0.5) # extinguish LED_1
                    if not recording.isSet():
                        self.log.debug("stopped recording")
                        LED_1_LED.stop()
                    if shutdown.isSet():
                        flushBuffer.set()
                        recording.clear()
            sleep(1)
        camera.close()
        self.log.debug("stopping camera thread")

## GpsPoller Thread

class GpsPoller(threading.Thread):
    def __init__(self, name,log):

        threading.Thread.__init__(self)
        self.name = name
        self.log = log
        self.log.debug("GPS thread initialised")
        global gpsd #bring it in scope
        gpsd = gps(mode=WATCH_ENABLE) #starting the stream of info
        current_value = None
        self.running = True #setting the thread running to true

    def run(self):
        global shutdown, gpsd
        self.log.debug("GPS thread running")
        while not shutdown.isSet():
            gpsd.next() #this will continue to loop and grab EACH set of gpsd info to clear the buffer
        self.log.debug("stopping GPS thread")


class PiDashCam(Daemon):
    def __init__(self, pidfile, loglevel=logging.NOTSET):
        Daemon.__init__(self, pidfile)
        self.loglevel = loglevel
        self.log = logging.getLogger(__name__)
        self.log.setLevel(self.loglevel)
        handler = logging.handlers.SysLogHandler(address = '/dev/log')
        formatter = logging.Formatter('%(module)s[%(process)s]: <%(levelname)s>: %(message)s')
        handler.setFormatter(formatter)
        self.log.addHandler(handler)

        signal.signal(signal.SIGTERM, self.sigcatch)

    def setup(self):
        global LED_1, LED_1_LED, LED_2, LED_2_LED
        """
        GPIO initialisation

        Note: This cannot go in the __init__ method because the unix double-fork in the generic daemon code
		mucks up the initialisation of the GPIO system.

		So it is called in the over-ridden run method.
		"""

        GPIO.setmode(GPIO.BCM)
        GPIO.setwarnings(False)
        GPIO.setup(BUTTON_A, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        GPIO.setup(BUTTON_B, GPIO.IN, pull_up_down=GPIO.PUD_UP)

        GPIO.setup(LED_1, GPIO.OUT)
        LED_1_LED = GPIO.PWM(LED_1, 0.5)
        GPIO.setup(LED_2, GPIO.OUT)
        LED_2_LED = GPIO.PWM(LED_2, 0.25)

        GPIO.add_event_detect(BUTTON_A, GPIO.FALLING, callback=self.buttonAPressed, bouncetime=BOUNCE_TIME)
        GPIO.add_event_detect(BUTTON_B, GPIO.FALLING, callback=self.buttonBPressed, bouncetime=BOUNCE_TIME)

    def buttonAPressed(self, channel):
        """
        Button A interrupt service routine
        Flush the in-memory buffer
        """

        # This test is here because the user *might* have another HAT plugged in or another circuit that produces a
        # falling-edge signal on another GPIO pin.
        if channel != BUTTON_A:
            return

        self.log.debug('Button A has been pressed')
        global extraTime, LED_1_LED
        t = threading.Timer(extraTime, self.setFlushBuffer)
        t.start()
        LED_1_LED.ChangeFrequency(1)


    def buttonBPressed(self, channel):
        """
        Button B interrupt service routine
        Pause/resume recording
        """

        # This test is here because the user *might* have another HAT plugged in or another circuit that produces a
        # falling-edge signal on another GPIO pin.
        if channel != BUTTON_B:
            return

        global flushBuffer, recording, LED_2_LED
        self.log.debug('Button B has been pressed')
        if recording.isSet():
            flushBuffer.set()
            recording.clear()
            LED_1_LED.stop()
        else:
            recording.set()
            LED_1_LED.ChangeFrequency(0.5)


    def sigcatch(self, signum, frame):
        """
        Signal handler
        """

        if signum == signal.SIGTERM:
            sys.exit(0)

    def cleanup(self):
        """
        GPIO cleanup
        """

        self.log.debug("Cleanup")
        self.log.info("Stopped")
        GPIO.cleanup()


    def setFlushBuffer(self):
        global flushBuffer
        flushBuffer.set()

    def getch(self):
        ch = ' '
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch


    def run(self):
        """
        Super-class overloaded run method.
        """

        global recording, flushBuffer, shutdown, gpsT, cameraT, extraTime, LED_1_LED, LED_2_LED
        self.log.info("Started")

        # register function to cleanup at exit
        atexit.register(self.cleanup)

        self.setup()

        self.log.info('piDashCam version ' + str(rev) + " main thread")
        gpsT = GpsPoller("gpsT", self.log) # create the GPS thread
        gpsT.start()
        cameraT = CameraThread("cameraT",self.log) # ditto the Camera thread
        cameraT.start()
        recording.set()
        flushBuffer.clear()
        shutdown.clear()
        LED_1_LED.stop()
        LED_2_LED.stop()

        while not shutdown.isSet():
            char = self.getch()
            if char == "s":
                self.log.debug("save")
                t = threading.Timer(extraTime, self.setFlushBuffer)
                t.start()
            elif char == "q":
                self.log.debug("Shutdown")
                shutdown.set()
            sleep(1)
        self.log.info("Shutting down, waiting for threads to die")
        shutdown.set()
        gpsT.join()
        self.log.debug("GPS thread died")
        cameraT.join()
        self.log.debug("Camera thread died.")
        self.log.info("Exiting")

# parse the command-line
parser = argparse.ArgumentParser()
parser.add_argument('-l', '--log-level', help="Log level, 'info' or 'debug'", default='info', choices=['info', 'debug'])
group = parser.add_mutually_exclusive_group(required=True)
group.add_argument("-d", "--debug", help="Keep in the foreground, do not daemonize", action="store_true", default=False)
group.add_argument("-p", "--pid-file", help="PID file")
args = parser.parse_args()

dashcam = PiDashCam(args.pid_file, {'info':logging.INFO, 'debug':logging.DEBUG}[args.log_level])

# the argument to the start method is opposite of debug
dashcam.start(not args.debug)
