#!/usr/bin/python

"""PiDashCam Raspberry Pi dashcam

A systemd compliant multi-threaded daemon to record video and respond to button presses

"""

rev = '0.0.1dev2'
button_delay = 0.2
speedConv = 2.23694 # convert m/s to mph
BOUNCE_TIME = 300


import io, os, sys, picamera, threading, termios, tty
import atexit, socket
import RPi.GPIO as GPIO #to access the GPIO pins
from time import time, sleep
from signal import pause
from datetime import datetime, timedelta
import keyboard, logging, logging.handlers
from gps import *
import argparse
import logging
import logging.handlers
import xmltodict
import signal

# Inter-thread communication events
flushBuffer = threading.Event()
recording = threading.Event()
shutdown = threading.Event()

#global variables
gpsd = None
recordingLED = None


class CameraThread(threading.Thread):
    """CameraThread

    The thread that manages the PiCamera
    """

    def __init__(self, name):
        threading.Thread.__init__(self)
        self.name = name
        self.log = logging.getLogger(__name__)
        self.log.debug("CameraThread.__init__()")
        self.running = True
        self.camera = picamera.PiCamera()

    def run(self):
        global gpsd, destDir, speedConv, cameraFormat, fileExt, flushbuffer, buffSize, recording, shutdown
        global recordingLED
        self.log.debug("CameraThread.run()")

        self.camera.resolution = (cameraRes['h'], cameraRes['v'])
        self.camera.vflip = True
        self.camera.hflip = True
        self.camera.annotate_background = picamera.Color('black')
        stream = picamera.PiCameraCircularIO(self.camera, seconds=buffSize)


        while not shutdown.isSet():
            while recording.isSet():
                recordingLED.start(50)
                i = datetime.now()
                now = i.strftime('%d %b %d %H:%M:%S')
                self.log.debug('Recording to ' + str(buffSize) + ' seconds buffer at ' + now)
                self.camera.led = True
                self.camera.start_recording(stream, format=cameraFormat)
                while recording.isSet():
                    self.camera.wait_recording(0.2)
                    i = datetime.now()
                    now = i.strftime('%d-%b-%d %H:%M:%S')
                    lat = gpsd.fix.latitude
                    lon = gpsd.fix.longitude
                    speed = gpsd.fix.speed * speedConv
                    track = gpsd.fix.track
                    self.camera.annotate_text = now + " " + "{0:0.3f}".format(lat) + " " + "{0:0.3f}".format(lon) + " " + "{0:0.0f}".format(speed) + " m/s " + "{0:0.0f}".format(track) + " True"
                    if flushBuffer.isSet():
                        i = datetime.now()
                        f = i.strftime('%Y%m%d-%H%M%S.' + fileExt)
                        outFile = str(destDir) + '/' + f
                        self.log.debug('Flushing buffer to ' + outFile)
                        stream.copy_to(outFile)
                        self.log.debug('Switching back to recording to buffer..')
                        flushBuffer.clear()
                        recordingLED.ChangeFrequency(0.5) # extinguish LED_1
                    if not recording.isSet():
                        self.log.debug("Recording paused")
                        recordingLED.stop()
                    if shutdown.isSet():
                        flushBuffer.set()
                        recording.clear()
            sleep(1)
        self.camera.close()
        self.log.debug("Ending camera thread")

## GpsPoller Thread

class GpsPoller(threading.Thread):
    def __init__(self, name):

        threading.Thread.__init__(self)
        self.name = name
        self.log = logging.getLogger(__name__)
        self.log.debug("GPSPoller.__init__()")
        #bring the gps global variable into scope
        global gpsd
        #start updating the GPS info
        gpsd = gps(mode=WATCH_ENABLE)
        current_value = None
        self.running = True #setting the thread running to true

    def run(self):
        global shutdown, gpsd
        self.log.debug("GPSPoller.run()")
        while not shutdown.isSet():
            #Continue to loop and grab EACH set of gpsd info to clear the buffer
            gpsd.next()
        self.log.debug("Ending GPS thread")


class PiDashCam():
    def __init__(self):
        self.log  = logging.getLogger(__name__)
        self.log.debug("PiDashCam.__init__()")

        signal.signal(signal.SIGTERM, self.sigcatch)

        global recordingLED
        """
        GPIO initialisation

        Note: This cannot go in the __init__ method because the unix double-fork in the generic daemon code
		mucks up the initialisation of the GPIO system.

		So it is called in the over-ridden run method.
		"""
        GPIO.setmode(GPIO.BCM)
        GPIO.setwarnings(False)
        GPIO.setup(BUTTON_A, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        GPIO.setup(BUTTON_B, GPIO.IN, pull_up_down=GPIO.PUD_UP)

        GPIO.setup(LED_1, GPIO.OUT)
        recordingLED = GPIO.PWM(LED_1, 0.5)

        GPIO.add_event_detect(BUTTON_A, GPIO.FALLING, callback=self.buttonAPressed, bouncetime=BOUNCE_TIME)
        GPIO.add_event_detect(BUTTON_B, GPIO.FALLING, callback=self.buttonBPressed, bouncetime=BOUNCE_TIME)

    def buttonAPressed(self, channel):
        """
        Button A interrupt service routine
        Flush the in-memory buffer
        """

        # This test is here because the user *might* have another HAT plugged in or another circuit that produces a
        # falling-edge signal on another GPIO pin.
        if channel != BUTTON_A:
            return

        self.log.debug('Button A has been pressed')
        global extraTime
        global recordingLED
        t = threading.Timer(extraTime, self.setFlushBuffer)
        t.start()
        recordingLED.ChangeFrequency(1)


    def buttonBPressed(self, channel):
        """
        Button B interrupt service routine
        Pause/resume recording
        """

        # This test is here because the user *might* have another HAT plugged in or another circuit that produces a
        # falling-edge signal on another GPIO pin.
        if channel != BUTTON_B:
            return

        global flushBuffer, recording
        global recordingLED
        self.log.debug('Button B has been pressed')
        if recording.isSet():
            flushBuffer.set()
            recording.clear()
            recordingLED.stop()
        else:
            recording.set()
            recordingLED.ChangeFrequency(0.5)


    def sigcatch(self, signum, frame):
        """
        Signal handler
        """
        global shutdown

        if signum == signal.SIGTERM:
            shutdown.set()
            sleep(1)
            sys.exit(0)

    def cleanup(self):
        """
        GPIO cleanup
        """
        #TODO: close other threads down before quitting?

        self.log.debug("Cleanup")
        self.log.info("Stopped")
        GPIO.cleanup()


    def setFlushBuffer(self):
        global flushBuffer
        flushBuffer.set()

    def getch(self):
        ch = ' '
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch


    def run(self):
        """
        Super-class overloaded run method.
        """

        global recording, flushBuffer, shutdown, gpsT, cameraT, extraTime
        global recordingLED
        self.log.debug("PiDashCam.run()")

        # register function to cleanup at exit
        atexit.register(self.cleanup)

        gpsT = GpsPoller("gpsT") # create the GPS thread
        gpsT.start()
        cameraT = CameraThread("cameraT") # ditto the Camera thread
        cameraT.start()
        recording.set()
        flushBuffer.clear()
        shutdown.clear()

        while not shutdown.isSet():
            if sys.stdin.isatty():
                char = self.getch()
                if char == "s":
                    self.log.debug("save")
                    t = threading.Timer(extraTime, self.setFlushBuffer)
                    t.start()
                elif char == "q":
                    self.log.debug("Shutdown")
                    shutdown.set()
                    sleep(1)

        self.log.debug("Shutting down, waiting for threads to die")
        shutdown.set()
        gpsT.join()
        self.log.debug("GPS thread died")
        cameraT.join()
        self.log.debug("Camera thread died.")
        self.log.info("Exiting")

class OneLineExceptionFormatter(logging.Formatter):
    def formatException(self, exc_info):
        result = super().formatException(exc_info)
        return repr(result)

    def format(self, record):
        result = super().format(record)
        if record.exc_text:
            result = result.replace("n", "")
        return result

# parse the command-line
parser = argparse.ArgumentParser()
parser.add_argument('-pre', '--prerecord', help='Pre-recording time (secs)', default='30')
parser.add_argument('-post', '--postrecord', help='Post-recording time (secs)', default='30')
parser.add_argument('-res', '--resolution', help='video resolution (hxv) in pixels', default='1440x1280')
parser.add_argument('-ba', '--button_a', help='Button A GPIO Pin', default='23')
parser.add_argument('-bb', '--button_b', help='Button B GPIO Pin', default='24')
parser.add_argument('-led', '--led', help='LED GPIO Pin', default='16')
parser.add_argument('-d', '--destdir', help='Destination directory for videos',  default='/home/pi/videos')
parser.add_argument('-e', '--ext', help="format of video, 'h264' or 'mjpeg'", default='h264', choices=['h264', 'mjpeg'])
parser.add_argument('-l', '--log-level', help="Log level, 'info' or 'debug'", default='info', choices=['info', 'debug'])
args = parser.parse_args()
#handler = logging.StreamHandler()
#formatter = OneLineExceptionFormatter(logging.BASIC_FORMAT)
#handler.setFormatter(formatter)
logging.basicConfig(level = {'info':logging.INFO, 'debug':logging.DEBUG}[args.log_level])
log = logging.getLogger("pidashcam")
#log.addHandler(handler)
log.setLevel({'info':logging.INFO, 'debug':logging.DEBUG}[args.log_level])
log.info("piDashCam version "  + str(rev) + " started")
log.debug(args)
destDir = args.destdir
BUTTON_A = int(args.button_a)
BUTTON_B = int(args.button_b)
LED_1 = int(args.led)
cameraRes = {'h': 1440,'v': 1280}
buffSize = int(args.prerecord)
extraTime = int(args.postrecord)
cameraFormat = args.ext
dashcam = PiDashCam()
dashcam.run()
